/*
 * generated by Xtext 2.17.0
 */
package br.ufes.inf.pg.validation

import br.ufes.inf.pg.storyGen.StoryGenPackage
import org.eclipse.xtext.validation.Check
import br.ufes.inf.pg.storyGen.Event
import br.ufes.inf.pg.storyGen.Attribute
import br.ufes.inf.pg.storyGen.Existent
import br.ufes.inf.pg.storyGen.Space
import br.ufes.inf.pg.storyGen.Plot
import br.ufes.inf.pg.storyGen.Expression
import br.ufes.inf.pg.storyGen.QuantityAttribute
import br.ufes.inf.pg.storyGen.FactAttribute
import br.ufes.inf.pg.storyGen.AttributionOperator
import br.ufes.inf.pg.storyGen.HappeningEvent
import br.ufes.inf.pg.storyGen.BooleanTerm
import br.ufes.inf.pg.storyGen.IntegerTerm
import br.ufes.inf.pg.storyGen.OrExpression
import br.ufes.inf.pg.storyGen.AndExpression
import br.ufes.inf.pg.storyGen.ComparisonExpression
import br.ufes.inf.pg.storyGen.Actor
import br.ufes.inf.pg.storyGen.ActionEvent
import br.ufes.inf.pg.storyGen.Term
import br.ufes.inf.pg.storyGen.ExistentAttributeTerm
import br.ufes.inf.pg.storyGen.StoryAttributeTerm
import org.eclipse.emf.common.util.EList
import br.ufes.inf.pg.storyGen.Change
import br.ufes.inf.pg.storyGen.TriggerCondition
import br.ufes.inf.pg.storyGen.StoryData
import br.ufes.inf.pg.storyGen.OrderCondition
import br.ufes.inf.pg.storyGen.Order
import br.ufes.inf.pg.storyGen.EventPriority

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class StoryGenValidator extends AbstractStoryGenValidator {
	
//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					StoryGenPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}



//	@Check
//	def checkAbstractHeritage(Actor actor) {
//		if(actor.superType !== null && !actor.superType.isAbstract) {
//			error('Actors cannot be a subtype of non-abstract actor.',
//				StoryGenPackage.Literals.ACTOR__SUPER_TYPE
//			);
//		}
//	}
//	
//	@Check
//	def checkAbstractHeritage(br.ufes.inf.pg.storyGen.Object obj) {
//		if(obj.superType !== null && !obj.superType.isAbstract) {
//			error('Objects cannot be a subtype of non-abstract object.',
//				StoryGenPackage.Literals.OBJECT__SUPER_TYPE
//			);
//		}
//	}
//
// 
//	@Check
//	def checkInheritanceCycle(Actor actor) {
//		var parent = actor.superType
//
//		while (parent !== null) {
//			if (actor.name == parent.name) {
//				error('An actor cannot specialize itself.',
//					StoryGenPackage.Literals.ACTOR__SUPER_TYPE
//				);
//				parent = null;
//			} else {
//				parent = parent.superType;
//			}
//		}
//	}
//	
//	@Check
//	def checkInheritanceCycle(br.ufes.inf.pg.storyGen.Object object) {
//		var parent = object.superType
//
//		while (parent !== null) {
//			if (object.name == parent.name) {
//				error('An actor cannot specialize itself.',
//					StoryGenPackage.Literals.ACTOR__SUPER_TYPE
//				);
//				parent = null;
//			} else {
//				parent = parent.superType;
//			}
//		}
//	}

	//
	// Only one Player
	//
	@Check
	def void checkAtLeastOnePlayableActor(Space space) {
		if(!space.existents.filter(Actor).exists[a | a.isPlayable]) {
			error("One playable actor is required.",
					StoryGenPackage.Literals.SPACE__EXISTENTS);
		}
	}

	@Check
	def void checkSinglePlayableActor(Actor actor) {
		if(!actor.isPlayable) return;
		
		var space = actor.eContainer as Space;
		
		for (other : space.existents.filter(Actor)) {
			if (other != actor && other.isPlayable) {
				error("There can only be ONE playable actor.",
					StoryGenPackage.Literals.ACTOR__PLAYABLE);
				
				return;
			}
		}
	}
	//
	//
	
	//
	// Check for unique names
	//
	@Check
	def void checkExistentNameIsUnique(Existent existent) {
		var space = existent.eContainer as Space;

		for (other : space.existents) {
			if (other != existent && existent.name.equals(other.name)) {
				error(
					"Existent names have to be unique.",
					StoryGenPackage.Literals.EXISTENT__NAME
				);
				return;
			}
		}
	}
	
	@Check
	def void checkEventNameIsUnique(Event event) {
		var plot = event.eContainer as Plot;

		for (other : plot.events) {
			if (other != event && event.name.equals(other.name)) {
				error(
					"Event names have to be unique.",
					StoryGenPackage.Literals.EVENT__NAME
				);
				return;
			}
		}
	}
	
	@Check
	def void checkAttributeNameIsUnique(Attribute attr) {
		var Existent existent = null;
		var EList<Attribute> attributes;
		
		if(attr.eContainer instanceof Existent) {
			existent = attr.eContainer as Existent;
			attributes = existent.attributes;
		}
		else if(attr.eContainer instanceof StoryData) {
			val storyData = attr.eContainer as StoryData;
		
			attributes.addAll(storyData.attributes);
		}
		
		
		if(existent !== null && existent.name.equals(attr.name)) {
			error(
					"Attribute name cannot be equal to the container Existent's name.",
					StoryGenPackage.Literals.ATTRIBUTE__NAME
				);
				return;
		}
		

		for (other : attributes) {
			if (other != attr && attr.name.equals(other.name)) {
				error(
					"Attribute names have to be unique in a given context.",
					StoryGenPackage.Literals.ATTRIBUTE__NAME
				);
				return;
			}
		}	
	}
	//
	//
	
	//
	// Check reserved name
	//
	@Check
	def void checkReservedNames(Existent existent) {
		val rn1 = "player";
		
		val existentName = existent.name.toLowerCase;
		
		if(existentName.equals(rn1)) {
			error(
				"This name is reserved. Please use another one.",
				StoryGenPackage.Literals.EXISTENT__NAME
			);
		}
	}
	
	@Check
	def void checkStoryDataReservedNames(Attribute attribute) {
		val rn1 = "__isover";
		
		val dataAttrName = attribute.name.toLowerCase;
		
		if(dataAttrName.equals(rn1)) {
			error(
				"This attribute name is reserved in this context. Please use another one.",
				StoryGenPackage.Literals.ATTRIBUTE__NAME
			);
		}
	}
	
	@Check
	def void checkReservedNames(Event event) {
		val rn1 = "opening";
		val rn2 = "endings";
		val rn3 = "happenings";
		val rn4 = "actions";
		var rn5 = "events";
		
		val eventName = event.name.toLowerCase;
		
		if(eventName.equals(rn1) || eventName.equals(rn2) ||
			eventName.equals(rn3) || eventName.equals(rn4) ||
			eventName.equals(rn5)) {
			error(
				"This name is reserved. Please use another one.",
				StoryGenPackage.Literals.EVENT__NAME
			);
		}
	}
	//
	//
	
	
	//
	// Check for opening and endings
	//
	@Check
	def void checkPlotOpening(Plot plot) {
		val openingsCount = plot.events
			.filter(HappeningEvent)
			.filter[e | e.isOpening].size;
		
		if(openingsCount <= 0) {
			error(
				"An opening event is required.",
				StoryGenPackage.Literals.PLOT__EVENTS
			);
		}
		else if(openingsCount > 1) {
			error(
				"Only ONE opening event is supported.",
				StoryGenPackage.Literals.PLOT__EVENTS
			);
		}
	}
	
	@Check
	def void checkAtLeastOneEndingEvent(Plot plot) {
		if(!plot.events.filter(HappeningEvent).exists[e | e.isEnding]) {
			error(
				"At least ONE ending event is required.",
				StoryGenPackage.Literals.PLOT__EVENTS
			);
		}
	}
	//
	//
	
	//
	// Check action's of Player
	//
	@Check
	def void checkActionOfPlayerActor(ActionEvent action) {
		if(!action.actor.isPlayable) return;
		
		if(action.shortDescription === null) {
			error(
				"Short description is mandatory for player actions.",
				StoryGenPackage.Literals.EVENT__SHORT_DESCRIPTION
			);
		}
		
		if(action.priority != EventPriority.NORMAL) {
			warning(
					"Event priority is ignored for player actions.",
					StoryGenPackage.Literals.EVENT__PRIORITY
				);
		}
	}
	//
	//
	
	//
	// Opening & Endings warnings
	//
	@Check
	def void checkOpeningEvent(HappeningEvent event) {
		if(!event.isOpening) return;
		
		if(event.conditions.length > 0) {
			warning(
					"Conditions for the opening event are ignored.",
					StoryGenPackage.Literals.EVENT__CONDITIONS
				);
		}
		
		if(event.priority != EventPriority.NORMAL) {
			warning(
					"Event priority is irrelevant for the opening event.",
					StoryGenPackage.Literals.EVENT__PRIORITY
				);
		}

	}
	
	@Check
	def void checkEndingEvent(HappeningEvent event) {
		if(!event.isEnding) return;
		
		if(event.changes.length > 0) {
			warning(
					"Changes in ending events are ignored.",
					StoryGenPackage.Literals.EVENT__CHANGES
				);
		}
		
		if(event.trigger !== null) {
			warning(
					"Triggers in ending events are ignored.",
					StoryGenPackage.Literals.EVENT__TRIGGER
				);
		}
	}
	//
	//
	
	//
	// Trigger related
	//
	@Check
	def void checkAvoidEventTriggerCycle(Event event) {
		var trigger = event.trigger
		val maxDepth = 50
		var i = 0
		
		while(trigger !== null && i < maxDepth) {
			if(trigger === event) {
				error("Trigger cycles are not permitted.",
				StoryGenPackage.Literals.EVENT__TRIGGER)
				
				trigger = null
			}
			else {
				trigger = trigger.trigger
			 	i++
			}
		}
		
		if(event.mayTriggers === null) return;
		
		for(mt : event.mayTriggers) {
			i = 0
			trigger = mt
		
			while(trigger !== null && i < maxDepth) {
				if(trigger === event) {
					error("Trigger cycles are not permitted.",
					StoryGenPackage.Literals.EVENT__MAY_TRIGGERS);
					
					trigger = null
				}
				else {
					trigger = trigger.trigger
					i++
				}
			}
		}
		
	}
	
	@Check
	def void checkRepeatedMayTriggers(Event event) {
		if(event.mayTriggers === null || event.mayTriggers.length == 0) return;
		
		for (mt : event.mayTriggers) {
			if(event.mayTriggers.filter[e | e == mt].length > 1) {
				error(
						"Duplicated possible triggers are not permitted.",
						StoryGenPackage.Literals.EVENT__MAY_TRIGGERS
					);
			}
		}
	}
	
	@Check
	def void checkTriggerCondition(Event event) {	
		if(event.conditions.exists[c | c instanceof TriggerCondition] &&
			!(event.eContainer as Plot).events.exists(e | e.trigger == event || e.mayTriggers.exists[mt | mt == event])) {
				warning("No other event triggers this trigger-required event. Therefore it will never occur.",
					StoryGenPackage.Literals.EVENT__CONDITIONS);
			}
	}
	//
	//
	
	//
 	// Check order condition
 	//
 	def void checkOrderCondition(OrderCondition cond) {
 		val eventContainer = cond.eContainer as Event
 		
 		if(cond.order == Order.AFTER && cond.event === eventContainer) {
 			warning("This condition will never be true.",
 				StoryGenPackage.Literals.ORDER_CONDITION__EVENT
 			)
 		}
 	}
	
	//
 	// Check boolean expressions
 	//
	@Check
	def void checkOrExpression(OrExpression expr) {
		for(operand : expr.operands) {
			if (!isOperandBoolean(operand)) {
				error("Logical expressions can only be evaluated with boolean values or FACT attributes.",
					StoryGenPackage.Literals.OR_EXPRESSION__OPERANDS);
			}
		}
	}
	
	@Check
	def void checkAndExpression(AndExpression expr) {
		for(operand : expr.operands) {
			if (!isOperandBoolean(operand)) {
				error("Logical expressions can only be evaluated with boolean values or FACT attributes.",
					StoryGenPackage.Literals.AND_EXPRESSION__OPERANDS);
			}
		}
	}
	
	@Check
	def void checkComparisonExpression(ComparisonExpression expr) {
		if((isOperandBoolean(expr.left) && isOperandInteger(expr.right)) ||
		   (isOperandInteger(expr.left) && isOperandBoolean(expr.right))) {
		
			error("Invalid comparison expression. Operands must be of same type.",
					StoryGenPackage.Literals.COMPARISON_EXPRESSION__OPERATOR);
		}
	}
	//
	//
	
	//
	// Check Change expressions
	//
	@Check
	def void checkChangeExpression(Change change) {
		if(change.term === null) return;
		
		if(isBoolTerm(change.term) && change.op != AttributionOperator.ASSIGN) {
			error("Logical Terms can only be used in assignments in this context.",
			StoryGenPackage.Literals.CHANGE__TERM);
		}
		
		if(isFactAttribute(change.attribute)) {
			if(change.op != AttributionOperator.ASSIGN) {
				error("FACT attributes can only be assigned in this context.",
				StoryGenPackage.Literals.CHANGE__ATTRIBUTE);
			}
			if(!isBoolTerm(change.term)) {
				error("FACT attributes can only be modified using boolean values.",
				StoryGenPackage.Literals.CHANGE__ATTRIBUTE);
			}
		}
		else if(isQuantityAttribute(change.attribute)) {
			if(!isIntTerm(change.term)) {
				error("QUANTITY attributes can only be modified using integer values.",
				StoryGenPackage.Literals.CHANGE__TERM);
			}
		}
	}
	//
	//
	
	
	// Operand is Boolean?
	def boolean isOperandBoolean(Expression operand) {
		if (operand instanceof IntegerTerm) {
			return false;
		}
		else if (operand instanceof ExistentAttributeTerm &&
		   (operand as ExistentAttributeTerm).attribute instanceof QuantityAttribute) {
		   	return false;
		}
		else if (operand instanceof StoryAttributeTerm &&
			(operand as StoryAttributeTerm).attribute instanceof QuantityAttribute) {
				return false;
		}
		else {
			return true;
		}
	}
	
	// Operand is Integer?
	def boolean isOperandInteger(Expression operand) {
		return !isOperandBoolean(operand);
	}
	
	
	// Term is Boolean?
	def boolean isBoolTerm(Term term) {
		if(term instanceof BooleanTerm) {
			return true;
		}
		else if(term instanceof IntegerTerm) {
			return false;
		}
		else if(term instanceof ExistentAttributeTerm) {
			return isFactAttribute(term.attribute);
		}
		else if(term instanceof StoryAttributeTerm) {
			return isFactAttribute(term.attribute);
		}
		else {
			throw new Exception("Unexpected Term type.");
		}
	}
	
	// Term is Integer?
	def boolean isIntTerm(Term term) {
		return !isBoolTerm(term);
	}
	
	
	// Attribute is Fact?
	def boolean isFactAttribute(Attribute attr) {
		return attr instanceof FactAttribute;
	}
	
	// Attribute is Quantity?
	def boolean isQuantityAttribute(Attribute attr) {
		return attr instanceof QuantityAttribute;
	}
}
