/**
 * generated by Xtext 2.17.0
 */
package br.ufes.inf.pg.scoping;

import br.ufes.inf.pg.storyGen.Attribute;
import br.ufes.inf.pg.storyGen.Change;
import br.ufes.inf.pg.storyGen.Existent;
import br.ufes.inf.pg.storyGen.ExistentAttributeTerm;
import br.ufes.inf.pg.storyGen.ExistentChange;
import br.ufes.inf.pg.storyGen.Story;
import br.ufes.inf.pg.storyGen.StoryAttributeTerm;
import br.ufes.inf.pg.storyGen.StoryDataChange;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
@SuppressWarnings("all")
public class StoryGenScopeProvider extends AbstractDeclarativeScopeProvider {
  public IScope scope_ExistentAttributeTerm_attribute(final ExistentAttributeTerm ctx, final EReference ref) {
    return this.scope_AttributesOfExistent(ctx.getExistent());
  }
  
  public IScope scope_StoryAttributeTerm_attribute(final StoryAttributeTerm ctx, final EReference ref) {
    return null;
  }
  
  public IScope scope_Change_attribute(final Change ctx, final EReference ref) {
    if ((ctx instanceof ExistentChange)) {
      return this.scope_AttributesOfExistent(((ExistentChange)ctx).getExistent());
    } else {
      if ((ctx instanceof StoryDataChange)) {
        return this.scope_AttributesOfStoryData(ctx);
      }
    }
    return null;
  }
  
  public IScope scope_AttributesOfExistent(final Existent ex) {
    Existent existent = ex;
    if ((existent != null)) {
      EList<Attribute> attributes = existent.getAttributes();
      return Scopes.scopeFor(attributes);
    }
    return null;
  }
  
  public IScope scope_AttributesOfStoryData(final EObject ctx) {
    EObject _rootContainer = EcoreUtil2.getRootContainer(ctx);
    Story story = ((Story) _rootContainer);
    EList<Attribute> attributes = null;
    EList<Attribute> _attributes = story.getData().getAttributes();
    for (final Attribute attribute : _attributes) {
      attributes.add(attribute);
    }
    return Scopes.scopeFor(attributes);
  }
}
