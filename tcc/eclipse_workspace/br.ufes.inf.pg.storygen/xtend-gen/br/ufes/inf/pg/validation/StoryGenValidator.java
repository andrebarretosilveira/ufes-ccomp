/**
 * generated by Xtext 2.17.0
 */
package br.ufes.inf.pg.validation;

import br.ufes.inf.pg.storyGen.ActionEvent;
import br.ufes.inf.pg.storyGen.Actor;
import br.ufes.inf.pg.storyGen.AndExpression;
import br.ufes.inf.pg.storyGen.Attribute;
import br.ufes.inf.pg.storyGen.AttributionOperator;
import br.ufes.inf.pg.storyGen.BooleanTerm;
import br.ufes.inf.pg.storyGen.Change;
import br.ufes.inf.pg.storyGen.ComparisonExpression;
import br.ufes.inf.pg.storyGen.Condition;
import br.ufes.inf.pg.storyGen.Event;
import br.ufes.inf.pg.storyGen.EventPriority;
import br.ufes.inf.pg.storyGen.Existent;
import br.ufes.inf.pg.storyGen.ExistentAttributeTerm;
import br.ufes.inf.pg.storyGen.Expression;
import br.ufes.inf.pg.storyGen.FactAttribute;
import br.ufes.inf.pg.storyGen.HappeningEvent;
import br.ufes.inf.pg.storyGen.IntegerTerm;
import br.ufes.inf.pg.storyGen.OrExpression;
import br.ufes.inf.pg.storyGen.Order;
import br.ufes.inf.pg.storyGen.OrderCondition;
import br.ufes.inf.pg.storyGen.Plot;
import br.ufes.inf.pg.storyGen.QuantityAttribute;
import br.ufes.inf.pg.storyGen.Space;
import br.ufes.inf.pg.storyGen.StoryAttributeTerm;
import br.ufes.inf.pg.storyGen.StoryData;
import br.ufes.inf.pg.storyGen.StoryGenPackage;
import br.ufes.inf.pg.storyGen.Term;
import br.ufes.inf.pg.storyGen.TriggerCondition;
import br.ufes.inf.pg.validation.AbstractStoryGenValidator;
import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class StoryGenValidator extends AbstractStoryGenValidator {
  @Check
  public void checkAtLeastOnePlayableActor(final Space space) {
    final Function1<Actor, Boolean> _function = (Actor a) -> {
      return Boolean.valueOf(a.isPlayable());
    };
    boolean _exists = IterableExtensions.<Actor>exists(Iterables.<Actor>filter(space.getExistents(), Actor.class), _function);
    boolean _not = (!_exists);
    if (_not) {
      this.error("One playable actor is required.", 
        StoryGenPackage.Literals.SPACE__EXISTENTS);
    }
  }
  
  @Check
  public void checkSinglePlayableActor(final Actor actor) {
    boolean _isPlayable = actor.isPlayable();
    boolean _not = (!_isPlayable);
    if (_not) {
      return;
    }
    EObject _eContainer = actor.eContainer();
    Space space = ((Space) _eContainer);
    Iterable<Actor> _filter = Iterables.<Actor>filter(space.getExistents(), Actor.class);
    for (final Actor other : _filter) {
      if (((!Objects.equal(other, actor)) && other.isPlayable())) {
        this.error("There can only be ONE playable actor.", 
          StoryGenPackage.Literals.ACTOR__PLAYABLE);
        return;
      }
    }
  }
  
  @Check
  public void checkExistentNameIsUnique(final Existent existent) {
    EObject _eContainer = existent.eContainer();
    Space space = ((Space) _eContainer);
    EList<Existent> _existents = space.getExistents();
    for (final Existent other : _existents) {
      if (((!Objects.equal(other, existent)) && existent.getName().equals(other.getName()))) {
        this.error(
          "Existent names have to be unique.", 
          StoryGenPackage.Literals.EXISTENT__NAME);
        return;
      }
    }
  }
  
  @Check
  public void checkEventNameIsUnique(final Event event) {
    EObject _eContainer = event.eContainer();
    Plot plot = ((Plot) _eContainer);
    EList<Event> _events = plot.getEvents();
    for (final Event other : _events) {
      if (((!Objects.equal(other, event)) && event.getName().equals(other.getName()))) {
        this.error(
          "Event names have to be unique.", 
          StoryGenPackage.Literals.EVENT__NAME);
        return;
      }
    }
  }
  
  @Check
  public void checkAttributeNameIsUnique(final Attribute attr) {
    Existent existent = null;
    EList<Attribute> attributes = null;
    EObject _eContainer = attr.eContainer();
    if ((_eContainer instanceof Existent)) {
      EObject _eContainer_1 = attr.eContainer();
      existent = ((Existent) _eContainer_1);
      attributes = existent.getAttributes();
    } else {
      EObject _eContainer_2 = attr.eContainer();
      if ((_eContainer_2 instanceof StoryData)) {
        EObject _eContainer_3 = attr.eContainer();
        final StoryData storyData = ((StoryData) _eContainer_3);
        attributes.addAll(storyData.getAttributes());
      }
    }
    if (((existent != null) && existent.getName().equals(attr.getName()))) {
      this.error(
        "Attribute name cannot be equal to the container Existent\'s name.", 
        StoryGenPackage.Literals.ATTRIBUTE__NAME);
      return;
    }
    for (final Attribute other : attributes) {
      if (((!Objects.equal(other, attr)) && attr.getName().equals(other.getName()))) {
        this.error(
          "Attribute names have to be unique in a given context.", 
          StoryGenPackage.Literals.ATTRIBUTE__NAME);
        return;
      }
    }
  }
  
  @Check
  public void checkReservedNames(final Existent existent) {
    final String rn1 = "player";
    final String existentName = existent.getName().toLowerCase();
    boolean _equals = existentName.equals(rn1);
    if (_equals) {
      this.error(
        "This name is reserved. Please use another one.", 
        StoryGenPackage.Literals.EXISTENT__NAME);
    }
  }
  
  @Check
  public void checkStoryDataReservedNames(final Attribute attribute) {
    final String rn1 = "__isover";
    final String dataAttrName = attribute.getName().toLowerCase();
    boolean _equals = dataAttrName.equals(rn1);
    if (_equals) {
      this.error(
        "This attribute name is reserved in this context. Please use another one.", 
        StoryGenPackage.Literals.ATTRIBUTE__NAME);
    }
  }
  
  @Check
  public void checkReservedNames(final Event event) {
    final String rn1 = "opening";
    final String rn2 = "endings";
    final String rn3 = "happenings";
    final String rn4 = "actions";
    String rn5 = "events";
    final String eventName = event.getName().toLowerCase();
    if (((((eventName.equals(rn1) || eventName.equals(rn2)) || 
      eventName.equals(rn3)) || eventName.equals(rn4)) || 
      eventName.equals(rn5))) {
      this.error(
        "This name is reserved. Please use another one.", 
        StoryGenPackage.Literals.EVENT__NAME);
    }
  }
  
  @Check
  public void checkPlotOpening(final Plot plot) {
    final Function1<HappeningEvent, Boolean> _function = (HappeningEvent e) -> {
      return Boolean.valueOf(e.isOpening());
    };
    final int openingsCount = IterableExtensions.size(IterableExtensions.<HappeningEvent>filter(Iterables.<HappeningEvent>filter(plot.getEvents(), HappeningEvent.class), _function));
    if ((openingsCount <= 0)) {
      this.error(
        "An opening event is required.", 
        StoryGenPackage.Literals.PLOT__EVENTS);
    } else {
      if ((openingsCount > 1)) {
        this.error(
          "Only ONE opening event is supported.", 
          StoryGenPackage.Literals.PLOT__EVENTS);
      }
    }
  }
  
  @Check
  public void checkAtLeastOneEndingEvent(final Plot plot) {
    final Function1<HappeningEvent, Boolean> _function = (HappeningEvent e) -> {
      return Boolean.valueOf(e.isEnding());
    };
    boolean _exists = IterableExtensions.<HappeningEvent>exists(Iterables.<HappeningEvent>filter(plot.getEvents(), HappeningEvent.class), _function);
    boolean _not = (!_exists);
    if (_not) {
      this.error(
        "At least ONE ending event is required.", 
        StoryGenPackage.Literals.PLOT__EVENTS);
    }
  }
  
  @Check
  public void checkActionOfPlayerActor(final ActionEvent action) {
    boolean _isPlayable = action.getActor().isPlayable();
    boolean _not = (!_isPlayable);
    if (_not) {
      return;
    }
    String _shortDescription = action.getShortDescription();
    boolean _tripleEquals = (_shortDescription == null);
    if (_tripleEquals) {
      this.error(
        "Short description is mandatory for player actions.", 
        StoryGenPackage.Literals.EVENT__SHORT_DESCRIPTION);
    }
    EventPriority _priority = action.getPriority();
    boolean _notEquals = (!Objects.equal(_priority, EventPriority.NORMAL));
    if (_notEquals) {
      this.warning(
        "Event priority is ignored for player actions.", 
        StoryGenPackage.Literals.EVENT__PRIORITY);
    }
  }
  
  @Check
  public void checkOpeningEvent(final HappeningEvent event) {
    boolean _isOpening = event.isOpening();
    boolean _not = (!_isOpening);
    if (_not) {
      return;
    }
    int _length = ((Object[])Conversions.unwrapArray(event.getConditions(), Object.class)).length;
    boolean _greaterThan = (_length > 0);
    if (_greaterThan) {
      this.warning(
        "Conditions for the opening event are ignored.", 
        StoryGenPackage.Literals.EVENT__CONDITIONS);
    }
    EventPriority _priority = event.getPriority();
    boolean _notEquals = (!Objects.equal(_priority, EventPriority.NORMAL));
    if (_notEquals) {
      this.warning(
        "Event priority is irrelevant for the opening event.", 
        StoryGenPackage.Literals.EVENT__PRIORITY);
    }
  }
  
  @Check
  public void checkEndingEvent(final HappeningEvent event) {
    boolean _isEnding = event.isEnding();
    boolean _not = (!_isEnding);
    if (_not) {
      return;
    }
    int _length = ((Object[])Conversions.unwrapArray(event.getChanges(), Object.class)).length;
    boolean _greaterThan = (_length > 0);
    if (_greaterThan) {
      this.warning(
        "Changes in ending events are ignored.", 
        StoryGenPackage.Literals.EVENT__CHANGES);
    }
    Event _trigger = event.getTrigger();
    boolean _tripleNotEquals = (_trigger != null);
    if (_tripleNotEquals) {
      this.warning(
        "Triggers in ending events are ignored.", 
        StoryGenPackage.Literals.EVENT__TRIGGER);
    }
  }
  
  @Check
  public void checkAvoidEventTriggerCycle(final Event event) {
    Event trigger = event.getTrigger();
    final int maxDepth = 50;
    int i = 0;
    while (((trigger != null) && (i < maxDepth))) {
      if ((trigger == event)) {
        this.error("Trigger cycles are not permitted.", 
          StoryGenPackage.Literals.EVENT__TRIGGER);
        trigger = null;
      } else {
        trigger = trigger.getTrigger();
        i++;
      }
    }
    EList<Event> _mayTriggers = event.getMayTriggers();
    boolean _tripleEquals = (_mayTriggers == null);
    if (_tripleEquals) {
      return;
    }
    EList<Event> _mayTriggers_1 = event.getMayTriggers();
    for (final Event mt : _mayTriggers_1) {
      {
        i = 0;
        trigger = mt;
        while (((trigger != null) && (i < maxDepth))) {
          if ((trigger == event)) {
            this.error("Trigger cycles are not permitted.", 
              StoryGenPackage.Literals.EVENT__MAY_TRIGGERS);
            trigger = null;
          } else {
            trigger = trigger.getTrigger();
            i++;
          }
        }
      }
    }
  }
  
  @Check
  public void checkRepeatedMayTriggers(final Event event) {
    if (((event.getMayTriggers() == null) || (((Object[])Conversions.unwrapArray(event.getMayTriggers(), Object.class)).length == 0))) {
      return;
    }
    EList<Event> _mayTriggers = event.getMayTriggers();
    for (final Event mt : _mayTriggers) {
      final Function1<Event, Boolean> _function = (Event e) -> {
        return Boolean.valueOf(Objects.equal(e, mt));
      };
      int _length = ((Object[])Conversions.unwrapArray(IterableExtensions.<Event>filter(event.getMayTriggers(), _function), Object.class)).length;
      boolean _greaterThan = (_length > 1);
      if (_greaterThan) {
        this.error(
          "Duplicated possible triggers are not permitted.", 
          StoryGenPackage.Literals.EVENT__MAY_TRIGGERS);
      }
    }
  }
  
  @Check
  public void checkTriggerCondition(final Event event) {
    if ((IterableExtensions.<Condition>exists(event.getConditions(), ((Function1<Condition, Boolean>) (Condition c) -> {
      return Boolean.valueOf((c instanceof TriggerCondition));
    })) && 
      (!IterableExtensions.<Event>exists(((Plot) event.eContainer()).getEvents(), ((Function1<Event, Boolean>) (Event e) -> {
        return Boolean.valueOf((Objects.equal(e.getTrigger(), event) || IterableExtensions.<Event>exists(e.getMayTriggers(), ((Function1<Event, Boolean>) (Event mt) -> {
          return Boolean.valueOf(Objects.equal(mt, event));
        }))));
      }))))) {
      this.warning("No other event triggers this trigger-required event. Therefore it will never occur.", 
        StoryGenPackage.Literals.EVENT__CONDITIONS);
    }
  }
  
  public void checkOrderCondition(final OrderCondition cond) {
    EObject _eContainer = cond.eContainer();
    final Event eventContainer = ((Event) _eContainer);
    if ((Objects.equal(cond.getOrder(), Order.AFTER) && (cond.getEvent() == eventContainer))) {
      this.warning("This condition will never be true.", 
        StoryGenPackage.Literals.ORDER_CONDITION__EVENT);
    }
  }
  
  @Check
  public void checkOrExpression(final OrExpression expr) {
    EList<Expression> _operands = expr.getOperands();
    for (final Expression operand : _operands) {
      boolean _isOperandBoolean = this.isOperandBoolean(operand);
      boolean _not = (!_isOperandBoolean);
      if (_not) {
        this.error("Logical expressions can only be evaluated with boolean values or FACT attributes.", 
          StoryGenPackage.Literals.OR_EXPRESSION__OPERANDS);
      }
    }
  }
  
  @Check
  public void checkAndExpression(final AndExpression expr) {
    EList<Expression> _operands = expr.getOperands();
    for (final Expression operand : _operands) {
      boolean _isOperandBoolean = this.isOperandBoolean(operand);
      boolean _not = (!_isOperandBoolean);
      if (_not) {
        this.error("Logical expressions can only be evaluated with boolean values or FACT attributes.", 
          StoryGenPackage.Literals.AND_EXPRESSION__OPERANDS);
      }
    }
  }
  
  @Check
  public void checkComparisonExpression(final ComparisonExpression expr) {
    if (((this.isOperandBoolean(expr.getLeft()) && this.isOperandInteger(expr.getRight())) || (this.isOperandInteger(expr.getLeft()) && this.isOperandBoolean(expr.getRight())))) {
      this.error("Invalid comparison expression. Operands must be of same type.", 
        StoryGenPackage.Literals.COMPARISON_EXPRESSION__OPERATOR);
    }
  }
  
  @Check
  public void checkChangeExpression(final Change change) {
    Term _term = change.getTerm();
    boolean _tripleEquals = (_term == null);
    if (_tripleEquals) {
      return;
    }
    if ((this.isBoolTerm(change.getTerm()) && (!Objects.equal(change.getOp(), AttributionOperator.ASSIGN)))) {
      this.error("Logical Terms can only be used in assignments in this context.", 
        StoryGenPackage.Literals.CHANGE__TERM);
    }
    boolean _isFactAttribute = this.isFactAttribute(change.getAttribute());
    if (_isFactAttribute) {
      AttributionOperator _op = change.getOp();
      boolean _notEquals = (!Objects.equal(_op, AttributionOperator.ASSIGN));
      if (_notEquals) {
        this.error("FACT attributes can only be assigned in this context.", 
          StoryGenPackage.Literals.CHANGE__ATTRIBUTE);
      }
      boolean _isBoolTerm = this.isBoolTerm(change.getTerm());
      boolean _not = (!_isBoolTerm);
      if (_not) {
        this.error("FACT attributes can only be modified using boolean values.", 
          StoryGenPackage.Literals.CHANGE__ATTRIBUTE);
      }
    } else {
      boolean _isQuantityAttribute = this.isQuantityAttribute(change.getAttribute());
      if (_isQuantityAttribute) {
        boolean _isIntTerm = this.isIntTerm(change.getTerm());
        boolean _not_1 = (!_isIntTerm);
        if (_not_1) {
          this.error("QUANTITY attributes can only be modified using integer values.", 
            StoryGenPackage.Literals.CHANGE__TERM);
        }
      }
    }
  }
  
  public boolean isOperandBoolean(final Expression operand) {
    if ((operand instanceof IntegerTerm)) {
      return false;
    } else {
      if (((operand instanceof ExistentAttributeTerm) && 
        (((ExistentAttributeTerm) operand).getAttribute() instanceof QuantityAttribute))) {
        return false;
      } else {
        if (((operand instanceof StoryAttributeTerm) && 
          (((StoryAttributeTerm) operand).getAttribute() instanceof QuantityAttribute))) {
          return false;
        } else {
          return true;
        }
      }
    }
  }
  
  public boolean isOperandInteger(final Expression operand) {
    boolean _isOperandBoolean = this.isOperandBoolean(operand);
    return (!_isOperandBoolean);
  }
  
  public boolean isBoolTerm(final Term term) {
    try {
      if ((term instanceof BooleanTerm)) {
        return true;
      } else {
        if ((term instanceof IntegerTerm)) {
          return false;
        } else {
          if ((term instanceof ExistentAttributeTerm)) {
            return this.isFactAttribute(((ExistentAttributeTerm)term).getAttribute());
          } else {
            if ((term instanceof StoryAttributeTerm)) {
              return this.isFactAttribute(((StoryAttributeTerm)term).getAttribute());
            } else {
              throw new Exception("Unexpected Term type.");
            }
          }
        }
      }
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  public boolean isIntTerm(final Term term) {
    boolean _isBoolTerm = this.isBoolTerm(term);
    return (!_isBoolTerm);
  }
  
  public boolean isFactAttribute(final Attribute attr) {
    return (attr instanceof FactAttribute);
  }
  
  public boolean isQuantityAttribute(final Attribute attr) {
    return (attr instanceof QuantityAttribute);
  }
}
