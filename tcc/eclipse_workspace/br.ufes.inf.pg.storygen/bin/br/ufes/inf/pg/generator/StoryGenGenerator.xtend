/*
 * generated by Xtext 2.17.0
 */
package br.ufes.inf.pg.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import br.ufes.inf.pg.storyGen.Story
import br.ufes.inf.pg.storyGen.Space
import br.ufes.inf.pg.storyGen.Plot
import br.ufes.inf.pg.storyGen.Expression
import br.ufes.inf.pg.storyGen.FactAttribute
import br.ufes.inf.pg.storyGen.QuantityAttribute
import br.ufes.inf.pg.storyGen.ExpressionCondition
import br.ufes.inf.pg.storyGen.Order
import br.ufes.inf.pg.storyGen.OrderCondition
import br.ufes.inf.pg.storyGen.AttributionOperator
import br.ufes.inf.pg.storyGen.HappeningEvent
import br.ufes.inf.pg.storyGen.ActionEvent
import br.ufes.inf.pg.storyGen.AndExpression
import br.ufes.inf.pg.storyGen.OrExpression
import br.ufes.inf.pg.storyGen.ComparisonExpression
import br.ufes.inf.pg.storyGen.BooleanTerm
import br.ufes.inf.pg.storyGen.IntegerTerm
import br.ufes.inf.pg.storyGen.NegationExpression
import br.ufes.inf.pg.storyGen.Actor
import br.ufes.inf.pg.storyGen.ExistentChange
import br.ufes.inf.pg.storyGen.ExistentAttributeTerm
import br.ufes.inf.pg.storyGen.StoryAttributeTerm
import br.ufes.inf.pg.storyGen.StoryDataChange
import br.ufes.inf.pg.storyGen.TriggerCondition
import br.ufes.inf.pg.storyGen.Attribute
import org.eclipse.emf.common.util.EList
import br.ufes.inf.pg.storyGen.StoryData
import br.ufes.inf.pg.storyGen.Existent
import org.eclipse.emf.common.util.BasicEList
import br.ufes.inf.pg.storyGen.AttributeSettingFrequency

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class StoryGenGenerator extends AbstractGenerator {
	
//	Space space;
	Plot plot;

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) 
	{
		for (s : resource.allContents.toIterable.filter(Story))
		{
			fsa.generateFile("StoryManager.cs", s.convertStory)
		}
	}
	
	/*STORY GENERATOR GENERATION */
	def convertStory(Story s)
	{
//		space = s.space;
		plot = s.plot;
		
		var EList<Attribute> allAttributes = new BasicEList<Attribute>
		
		allAttributes.addAll(s.data.attributes)
				
		for(existent : s.space.existents) {
			allAttributes.addAll(existent.attributes)
		}
		
	'''
	using System;
	using System.Collections.Generic;
	using System.Linq;
	 
	namespace StoryManager
	{
		public static class Story
	    {
	        public static Space space;
			public static Plot plot;
			private static Selector selector;
			
			«FOR attribute : s.data.attributes»
			«attribute.convertAttribute(true)»
			«ENDFOR»
			public static bool __isOver;
	        public static List<Plot.Event> pastEvents;
	
	
	        public static void Init()
	        {
				plot = new Plot();
				space = new Space();
				selector = new Selector();
				
				plot.SetEventsRefs();
	
				«FOR attribute : s.data.attributes»
				«IF attribute instanceof QuantityAttribute»
					«val qa = attribute as QuantityAttribute»
					«qa.name» = «qa.initValue.convertExpression»;
				«ELSE»
					«val fa = attribute as FactAttribute»
					«IF fa.initValue !== null»
					«fa.name» = «fa.initValue.convertExpression»;
					«ENDIF»
				«ENDIF»
				«ENDFOR»
				__isOver = false;
				pastEvents = new List<Plot.Event>();
	        }
	
	        public static List<Plot.Event> Begin()
	        {
	            return selector.ApplyOpening();
	        }
	        
	        public static List<Plot.Event> Tick(Plot.Event playerAction)
	        {
	            return selector.ApplyNext(playerAction);;
	        }
	        
	        public static IDictionary<string, string> GetAttributes()
			{
				var attrs = new Dictionary<string, string>();
				
				«FOR attr : s.data.attributes»
				attrs.Add("«attr.name.toFirstUpper»", «attr.name.toFirstUpper» + "");
				«ENDFOR»
	
				return attrs;
			}
	
	        public static List<Plot.ActionEvent> GetPossiblePlayerActions()
	        {
	            if(Story.__isOver) return new List<Plot.ActionEvent>();
				
	            else return space.player.GetPossibleActions();
	        }
	
	        public static bool HasEventOcurred(Plot.Event consideredEvent)
	        {
	            return pastEvents.Any(e => e.Equals(consideredEvent));
	        }
	
	        //-----
	        #region Story Selector
	
	        public class Selector
	        {
	            Random random;
	
	            //
	            // Constructor
	            public Selector()
	            {
	                random = new Random();
	            }
	
	            public List<Plot.Event> ApplyOpening()
	            {
	                return ApplyEventChanges(plot.opening);
	            }
	
	            public List<Plot.Event> ApplyNext(Plot.Event playerAction)
	            {
	                List<Plot.Event> eventsApplied = new List<Plot.Event>();
	
	                if (playerAction != null)
	                {
	                    eventsApplied.AddRange(ApplyEventChanges(playerAction));
	                }
	
	                if(Story.__isOver) return eventsApplied;
	
	                var actionsToApply = CheckForOtherActorsActions();
	                foreach (var action in actionsToApply)
	                {
	                    if(Story.__isOver) return eventsApplied;
	
						if(!action.PreconditionsMet()) continue;
	
	                    eventsApplied.AddRange(ApplyEventChanges(action));
	                }
	
	                var happeningsToApply = CheckForHappenings();
					foreach (var happening in happeningsToApply)
					{
						if(Story.__isOver) return eventsApplied;
						
						if(!happening.PreconditionsMet()) continue;
	
						eventsApplied.AddRange(ApplyEventChanges(happening));
					}
	
	                return eventsApplied;
	            }
	
				«val quantityAttributes = allAttributes.filter(QuantityAttribute).filter(a | a.setting !== null)»
				«val everyEventAttrs = quantityAttributes.filter(a | a.setting.frequency == AttributeSettingFrequency.EVERY_EVENT)»
				«val everyHappeningAttrs = quantityAttributes.filter(a | a.setting.frequency == AttributeSettingFrequency.EVERY_HAPPENING)»
				«val everyActionAttrs = quantityAttributes.filter(a | a.setting.frequency == AttributeSettingFrequency.EVERY_ACTION)»
				«val everyPlayerActionAttrs = quantityAttributes.filter(a | a.setting.frequency == AttributeSettingFrequency.EVERY_PLAYER_ACTION)»

	            private List<Plot.Event> ApplyEventChanges(Plot.Event er)
	            {
	                List<Plot.Event> appliedEvents = new List<Plot.Event>();
	                
	                er.ApplyChanges();
	                Story.pastEvents.Add(er);
	
					appliedEvents.Add(er);
	
					// Increments every event
					«FOR a : everyEventAttrs»
					«IF a.eContainer instanceof StoryData»Story«ELSE»space.«(a.eContainer as Existent).name.toFirstLower»«ENDIF».«a.name.toFirstUpper» «IF a.setting.isPositive»+=«ELSE»-=«ENDIF» «a.setting.amount»;
					«ENDFOR»
	
					if(er is Plot.HappeningEvent)
					{
						// Increments every happening event
						«FOR a : everyHappeningAttrs»
						«IF a.eContainer instanceof StoryData»Story«ELSE»space.«(a.eContainer as Existent).name.toFirstLower»«ENDIF».«a.name.toFirstUpper» «IF a.setting.isPositive»+=«ELSE»-=«ENDIF» «a.setting.amount»;
						«ENDFOR»
					}
					else if(er is Plot.ActionEvent)
					{
						// Increments every action event
						«FOR a : everyActionAttrs»
						«IF a.eContainer instanceof StoryData»Story«ELSE»space.«(a.eContainer as Existent).name.toFirstLower»«ENDIF».«a.name.toFirstUpper» «IF a.setting.isPositive»+=«ELSE»-=«ENDIF» «a.setting.amount»;
						«ENDFOR»
	
						if(Story.space.player.actions.Contains(er))
						{
							// Increments every player action event
							«FOR a : everyPlayerActionAttrs»
							«IF a.eContainer instanceof StoryData»Story«ELSE»space.«(a.eContainer as Existent).name.toFirstLower»«ENDIF».«a.name.toFirstUpper» «IF a.setting.isPositive»+=«ELSE»-=«ENDIF» «a.setting.amount»;
							«ENDFOR»
						}
					}
	                
	                if(Story.plot.IsEnding(er)) 
					{
						Story.__isOver = true;
						
						return appliedEvents;
					}
					
					if(er.eventToTrigger != null)
					{
						appliedEvents.AddRange(ApplyEventChanges(er.eventToTrigger));
					}
					if(er.eventsThatMayTrigger != null)
					{
						var possibleTriggers = er.eventsThatMayTrigger.Where(t => t.PreconditionsMet(true));
						var triggers = ResolveEventsToHappen(possibleTriggers.ToList());
	
						foreach(var trigger in triggers)
						{
							appliedEvents.AddRange(ApplyEventChanges(trigger));
						}
					}

					return appliedEvents;
		        }

		        public List<Plot.Event> CheckForHappenings()
		        {
					return ResolveEventsToHappen(
						plot.GetPossibleHappenings()
						.Select(a => (Plot.Event) a).ToList()
					);
		        }
		        
		        public List<Plot.Event> CheckForOtherActorsActions()
		        {
		            var actors = space.actors;
		
		            List<Plot.Event> actionsToHappen = new List<Plot.Event>();
		
		            foreach (var actor in actors)
		            {
						actionsToHappen.AddRange(
							ResolveEventsToHappen(actor.GetPossibleActions()
							.Select(a => (Plot.Event) a).ToList())
						);
		            }
		
		            return actionsToHappen;
		        }
		
				private List<Plot.Event> ResolveEventsToHappen(List<Plot.Event> candidateEvents)
				{
					List<Plot.Event> eventsToHappen = new List<Plot.Event>();
		
					var highPriorEvents = candidateEvents.Where(e => e.priority == EventPriority.High).ToList();
					var veryHighPriorEvents = highPriorEvents.Where(e => e.priority == EventPriority.VeryHigh).ToList();
		
					if(veryHighPriorEvents.Count > 0)
					{
						// One or more veryhigh events
						eventsToHappen.AddRange(veryHighPriorEvents);
					}
					else if(highPriorEvents.Count > 0)
					{
						// One or more high events
						eventsToHappen.AddRange(highPriorEvents);
					}
		            else if (candidateEvents.Count > 0)
		            {
						// One random normal event
		                int r = random.Next(0, candidateEvents.Count);
		                eventsToHappen.Add(candidateEvents[r]);
		            }
		
					return eventsToHappen;
				}

	        }
	
	        #endregion
	    }
		
		«s.plot.convert»
		
		«s.space.convert»
		
		public enum ActionType
		{
			Idle,
			Visual,
			Interaction,
			Movement,
			Communication,
			Combat,
		}
		
		public enum EventPriority
		{
			Normal,
			High,
			VeryHigh
		}
	}
	
    '''
    }
	
     
    /* 
     * PLOT & Events
     */
     
	def convert(Plot plot)
	{
		val happenings = plot.events.filter(HappeningEvent)
		val actions = plot.events.filter(ActionEvent)
		
		val opening = happenings.findFirst[e | e.isOpening]
		val endings = happenings.filter(e | e.isEnding)
		
	''' 
	public class Plot
	{
		// Plot opening & endings
	    public HappeningEvent opening;
		public List<HappeningEvent> endings;
	
		// Happenings
		«FOR h : happenings»
		public HappeningEvent «h.name.toFirstLower»;
		«ENDFOR»
	
		// Actions
		«FOR a : actions»
		public ActionEvent «a.actor.name.toFirstLower»«a.name.toFirstUpper»;
		«ENDFOR»
	
		// Collections of Events
		public List<Event> events;
		public List<HappeningEvent> happenings;
		public List<ActionEvent> actions;
		
		
		public Plot()
		{
			«FOR h : happenings»
			«h.name.toFirstLower» = new «h.name.toFirstUpper»();
			«ENDFOR»
		
			«FOR a : actions»
			«a.actor.name.toFirstLower»«a.name.toFirstUpper» = new «a.actor.name.toFirstUpper»«a.name.toFirstUpper»();
			«ENDFOR»
			
			opening = «opening.name.toFirstLower»;
			endings = new List<HappeningEvent>() { «FOR end : endings»«end.name.toFirstLower», «ENDFOR» };
		
			happenings = new List<HappeningEvent>() { «FOR h : happenings.filter(h | !h.isOpening)»«h.name.toFirstLower», «ENDFOR» };
			actions = new List<ActionEvent>() { «FOR a : actions»«a.actor.name.toFirstLower»«a.name.toFirstUpper», «ENDFOR» };
			
			events = new List<Event>() { opening };
			events.AddRange(happenings);
			events.AddRange(actions);
			events.AddRange(endings);
		}
		
		public void SetEventsRefs()
		{
			foreach (var e in events)
			{
				e.SetReferences();
			}
		}
		
		public List<HappeningEvent> GetPossibleHappenings()
		{
			return happenings.Where(e => e.PreconditionsMet()).ToList();
		}
		
		public bool IsEnding(Event e)
		{
			if(e is ActionEvent) return false;
			
			return endings.Contains(e as HappeningEvent);
		}
		
		//-----
		#region Event Definitions

		public abstract class Event
		{
			public string name;
			public string description;
			public string shortDescription;
			
			public EventPriority priority;
			
			public Plot.Event eventToTrigger;
			public List<Plot.Event> eventsThatMayTrigger;
			
			public abstract bool PreconditionsMet(bool isTriggerCheck = false);
			public abstract void ApplyChanges();
			public abstract void SetReferences();

	   		// override object.Equals
	        public override bool Equals(object obj)
	        {
	            if (obj == null || GetType() != obj.GetType())
	            {
	                return false;
	            }

	            return (obj as Event).name == this.name;
	        }
	
	        // override object.GetHashCode
	        public override int GetHashCode()
	        {
	            return base.GetHashCode();
	        }
	    }
	
	    //-----
	    #region Happenings
	
	    public abstract class HappeningEvent : Event
	    {
	    }
	    
	    «FOR h : happenings»
	    «h.convert»
	    «ENDFOR»
	
	    #endregion
	
	    //-----
	    #region Actions
	
	    public abstract class ActionEvent : Event
	    {
	    	public ActionType type;
	    	public Space.StoryActor actor;
	    }
	    
	    «FOR a : actions»
	    «a.convert»
	    «ENDFOR»
	
	    #endregion
	
	    #endregion
	}
    '''
	}
	
	def convert(HappeningEvent he)
    '''
	public class «he.name.toFirstUpper» : HappeningEvent
	{	
		public «he.name.toFirstUpper»()
		{
			name = "«he.name.toFirstUpper»";
			description = "«he.description»";
			shortDescription = "«IF he.shortDescription !== null»«he.shortDescription»«ENDIF»";
			priority = EventPriority.«he.priority.literal.toFirstUpper»;
		}
		
		public override void SetReferences()
		{
			eventToTrigger = «IF he.trigger !== null»«IF he.trigger instanceof ActionEvent»Story.plot.«(he.trigger as ActionEvent).actor.name.toFirstLower»«he.trigger.name.toFirstUpper»«ELSE»Story.plot.«he.trigger.name.toFirstLower»«ENDIF»«ELSE»null«ENDIF»;

			«IF he.mayTriggers === null || he.mayTriggers.length == 0»
			eventsThatMayTrigger = null;
			«ELSE»
			eventsThatMayTrigger = new List<Plot.Event>() { «FOR e : he.mayTriggers»«IF e instanceof ActionEvent»Story.plot.«(e as ActionEvent).actor.name.toFirstLower»«e.name.toFirstUpper»«ELSE»Story.plot.«e.name.toFirstLower»«ENDIF», «ENDFOR» };
			«ENDIF»
		}
		
		public override bool PreconditionsMet(bool isTriggerCheck = false)
		{
			«IF he.conditions.exists[c | c instanceof TriggerCondition]»if(!isTriggerCheck) return false;«ENDIF»
			return («FOR c : he.conditions»(«c.convertCondition») && «ENDFOR» true);
		}
		
		public override void ApplyChanges()
		{
			«FOR c : he.changes»
			«c.convertChange»
			«ENDFOR»
		}
	}
	'''
	
	def convert(ActionEvent ae)
	'''
	public class «ae.actor.name.toFirstUpper»«ae.name.toFirstUpper» : ActionEvent
	{
		public «ae.actor.name.toFirstUpper»«ae.name.toFirstUpper»()
		{
			name = "«ae.name.toFirstUpper»";
			description = "«ae.description»";
			shortDescription = "«IF ae.shortDescription !== null»«ae.shortDescription»«ENDIF»";
			priority = EventPriority.«ae.priority.literal.toFirstUpper»;
			type = ActionType.«ae.type.literal.toFirstUpper»;
		}
		
		public override void SetReferences()
		{
			actor = Story.space.«ae.actor.name.toFirstLower»;

			eventToTrigger = «IF ae.trigger !== null»«IF ae.trigger instanceof ActionEvent»Story.plot.«(ae.trigger as ActionEvent).actor.name.toFirstLower»«ae.trigger.name.toFirstUpper»«ELSE»Story.plot.«ae.trigger.name.toFirstLower»«ENDIF»«ELSE»null«ENDIF»;

			«IF ae.mayTriggers === null || ae.mayTriggers.length == 0»
			eventsThatMayTrigger = null;
			«ELSE»
			eventsThatMayTrigger = new List<Plot.Event>() { «FOR mt : ae.mayTriggers»«IF mt instanceof ActionEvent»Story.plot.«(mt as ActionEvent).actor.name.toFirstLower»«mt.name.toFirstUpper»«ELSE»Story.plot.«mt.name.toFirstLower»«ENDIF», «ENDFOR» };
			«ENDIF»
		}
		
		public override bool PreconditionsMet(bool isTriggerCheck = false)
		{
			«IF ae.conditions.exists[c | c instanceof TriggerCondition]»if(!isTriggerCheck) return false;«ENDIF»
			return («FOR c : ae.conditions»(«c.convertCondition») && «ENDFOR» true);
		}
		
		public override void ApplyChanges()
		{
			«FOR c : ae.changes»
			«c.convertChange»
			«ENDFOR»
		}
	}
	'''
	
	/* 
     * SPACE & Existents
     */
    def convert(Space space) {
    	val actors = space.existents.filter(Actor)
    	val objects = space.existents.filter(br.ufes.inf.pg.storyGen.Object)
    	
    	val player = actors.findFirst[a | a.isPlayable]
    
    ''' 
	public class Space
	{
		// Player
		public «player.name.toFirstUpper» player;
		
	    // Actors
	    «FOR a : actors»
	    public «a.name.toFirstUpper» «a.name.toFirstLower»;
	    «ENDFOR»
	    
	    // Objects
	    «FOR o : objects»
	    public «o.name.toFirstUpper» «o.name.toFirstLower»;
	    «ENDFOR»
	
	    // Collections of Existents
	    public List<StoryExistent> existents;
	    public List<StoryActor> actors;
	    public List<StoryObject> objects;
	
		public Space()
		{
		    «FOR a : actors»
		    «a.name.toFirstLower» = new «a.name.toFirstUpper»();
		    «ENDFOR»

		    «FOR o : objects»
		    «o.name.toFirstLower» = new «o.name.toFirstUpper»();
		    «ENDFOR»

		    player = «player.name.toFirstLower»;

		    existents = new List<StoryExistent>() { «FOR e : space.existents»«e.name.toFirstLower», «ENDFOR» };
		    actors = new List<StoryActor>() { «FOR a : actors.filter(a | !a.isPlayable)»«a.name.toFirstLower», «ENDFOR» };
		    objects = new List<StoryObject>() { «FOR o : objects»«o.name.toFirstLower», «ENDFOR» };
		}
	
	
	    //-----
	    #region Existent Definitions
	
	    public abstract class StoryExistent
	    {
	    	public abstract IDictionary<string, string> GetAttributes();
	    }
	
	    //-----
	    #region Actors
	
	    public abstract class StoryActor : StoryExistent
	    {
	    	public string displayName;
	        public List<Plot.ActionEvent> actions;
	
	        public List<Plot.ActionEvent> GetPossibleActions()
	        {
	            return actions.Where(a => a.PreconditionsMet()).ToList();
	        }
	    }
	    
	    «FOR a : actors»
	    «a.convertExistent»
	    «ENDFOR»
	
	    #endregion
	
	    //-----
	    #region Objects
	
	    public abstract class StoryObject : StoryExistent
	    {
	    }
	    
	    «FOR o : objects»
	    «o.convertExistent»
	    «ENDFOR»
	
	    #endregion
	
	    #endregion
	}
    '''
    }
    
    def dispatch convertExistent(Actor actor) {
    	val actions = plot.events.filter(ActionEvent).filter(a | a.actor.equals(actor))
    
    '''   
	public class «actor.name.toFirstUpper» : StoryActor
	{   	
		public «actor.name.toFirstUpper»()
		{
			displayName = "«actor.displayName»";
			actions = new List<Plot.ActionEvent>() { «FOR a : actions»Story.plot.«a.actor.name.toFirstLower»«a.name.toFirstUpper», «ENDFOR» };
		}
		
		public override IDictionary<string, string> GetAttributes()
		{
			var attrs = new Dictionary<string, string>();
			
			«FOR attr : actor.attributes»
			attrs.Add("«attr.name.toFirstUpper»", «attr.name.toFirstUpper» + "");
			«ENDFOR»
	
			return attrs;
		}
		
    	«FOR attr : actor.attributes»
    	«attr.convertAttribute(false)»
    	«ENDFOR»
	}
    '''
    }
    
    def dispatch convertExistent(br.ufes.inf.pg.storyGen.Object object)
    '''
	public class «object.name.toFirstUpper» : StoryObject
	{
		public override IDictionary<string, string> GetAttributes()
		{
			var attrs = new Dictionary<string, string>();
			
			«FOR attr : object.attributes»
			attrs.Add("«attr.name.toFirstUpper»", «attr.name.toFirstUpper» + "");
			«ENDFOR»
	
			return attrs;
		}
				
		«FOR attr : object.attributes»
		«attr.convertAttribute(false)»
		«ENDFOR»
	}
    '''
    
      
    def dispatch convertAttribute(FactAttribute fa, boolean isStatic)
    '''
    «IF fa.initValue !== null»private «IF isStatic»static«ENDIF» bool «fa.name.toFirstLower» = «fa.initValue.value»;«ENDIF»
    public «IF isStatic»static«ENDIF» bool «fa.name.toFirstUpper»
    {
    	«IF fa.macroExp !== null»
    	get { return «fa.macroExp.convertExpression»; }
    	«ELSE»
    	get { return «fa.name.toFirstLower»; }
    	set { «fa.name.toFirstLower» = value; }
    	«ENDIF»
    }
    '''
    
    def dispatch convertAttribute(QuantityAttribute qa, boolean isStatic)
    '''
    private «IF isStatic»static«ENDIF» int «qa.name.toFirstLower» = «qa.initValue.value»;
    public «IF isStatic»static«ENDIF» int «qa.name.toFirstUpper»
    {
        get { return «qa.name.toFirstLower»; }
        set { «qa.name.toFirstLower» = value; }
    }
    '''
	
	
	/* 
     * CONDITIONs
     */
	
	def dispatch convertCondition(ExpressionCondition cond)
	'''
	«cond.exp.convertExpression»
	'''
	
	def dispatch convertCondition(OrderCondition cond)
	{
		val isActionEvent = (cond.event instanceof ActionEvent);
		
	'''
	«IF cond.order == Order.BEFORE»!«ENDIF»Story.HasEventOcurred(Story.plot.
	«IF isActionEvent»«(cond.event as ActionEvent).actor.name.toFirstLower»«cond.event.name.toFirstUpper»
	«ELSE»
	«cond.event.name.toFirstLower»
	«ENDIF»)
	'''
	}
	
	def dispatch convertCondition(TriggerCondition cond)
	'''
	true
	'''
	
	/* 
     * CHANGEs
     */
     def dispatch convertChange(ExistentChange change)
     '''
	 Story.space.«change.existent.name.toFirstLower».«change.attribute.name.toFirstUpper» 
	 «change.op.convert» «change.term.convertExpression»;
     '''
     
     def dispatch convertChange(StoryDataChange change)
     '''
     Story.«change.attribute.name.toFirstUpper» «change.op.convert» «change.term.convertExpression»;
     '''
     
//	def convertHappeningChange(Change change) 
//	'''
//	«IF change.existent.isAbstract»
//		«val validExistents = m_space.existents
//			.filter(e | e.isAbstract == true && e.superType === change.existent.superType)»
//		«FOR existent : validExistents»
//			space.«existent.name.toFirstLower».«change.attribute.name.toFirstUpper» 
//			«change.op.convert» «change.term.convertExpression»
//		«ENDFOR»
//	«ELSE»
//		space.«change.existent.name.toFirstLower».«change.attribute.name.toFirstUpper» 
//		«change.op.convert» «change.term.convertExpression»
//	«ENDIF»
//	'''
//	
//	def convertActionChange(Change change)
//	'''
//	«IF actor !== null && change.existent.isAbstract»
//		space.«actor.name.toFirstLower».«change.attribute.name.toFirstUpper» 
//		«change.op.convert» «change.term.convertExpression»
//	«ELSE»
//		space.«change.existent.name.toFirstLower».«change.attribute.name.toFirstUpper» 
//		«change.op.convert» «change.term.convertExpression»
//	«ENDIF»
//	'''
	
	
	/* 
     * EXPRESSIONs
     */
	
	def dispatch String convertExpression(AndExpression expr) {
		var convertedString = new String
		var i = 0
		for (operand : expr.operands) {
			if ((operand instanceof OrExpression) || (operand instanceof ComparisonExpression)) {
				convertedString += CSkeys.parOpen;
			} // /
			convertedString += convertExpression(operand);

			if ((operand instanceof OrExpression) || (operand instanceof ComparisonExpression)) {
				convertedString += CSkeys.parClose
			} // /
			if (i < expr.operands.size() - 1)
				convertedString += CSkeys.and;
			i++
		}
		return convertedString
	}

	def dispatch String convertExpression(OrExpression expr) {
		var convertedString = new String
		var i = 0
		for (operand : expr.operands) {

			if ((operand instanceof AndExpression) || (operand instanceof ComparisonExpression)) {
				convertedString += CSkeys.parOpen;
			}

			convertedString += convertExpression(operand);

			if ((operand instanceof AndExpression) || (operand instanceof ComparisonExpression)) {
				convertedString += CSkeys.parClose;
			}

			if (i < expr.operands.size() - 1)
				convertedString += CSkeys.or;
			i++
		}
		return convertedString
	}
	
	def dispatch String convertExpression(ComparisonExpression expr) {
		var convertedString = new String

		// left operand
		if ((expr.left instanceof AndExpression) ||
			(expr.left instanceof OrExpression)  ||
			(expr.left instanceof ComparisonExpression))
		{
			convertedString += CSkeys.parOpen;
		}

		convertedString += convertExpression(expr.left);
		
		if ((expr.left instanceof AndExpression) ||
			(expr.left instanceof OrExpression)  ||
			(expr.left instanceof ComparisonExpression))
		{
			convertedString += CSkeys.parClose;
		}
		
		// operator
		convertedString += expr.operator
		
		
		// right operand
		if ((expr.right instanceof AndExpression) ||
			(expr.right instanceof OrExpression)  ||
			(expr.right instanceof ComparisonExpression))
		{
			convertedString += CSkeys.parOpen;
		}
		
		convertedString += convertExpression(expr.right);

		if ((expr.right instanceof AndExpression) ||
			(expr.right instanceof OrExpression)  ||
			(expr.right instanceof ComparisonExpression))
		{
			convertedString += CSkeys.parClose;
		}
		
		return convertedString
	}

	def dispatch String convertExpression(NegationExpression expr) {
		var convertedString = new String;
		convertedString += CSkeys.not;

		if ((expr.operand instanceof AndExpression) ||
			(expr.operand instanceof OrExpression)  ||
			(expr.operand instanceof ComparisonExpression))
		{
			convertedString += CSkeys.parOpen;
		}

		convertedString += convertExpression(expr.operand);

		if ((expr.operand instanceof AndExpression) ||
			(expr.operand instanceof OrExpression)  ||
			(expr.operand instanceof ComparisonExpression))
		{
			convertedString += CSkeys.parClose;
		}

		return convertedString
	}
	
	def dispatch convertExpression(ExistentAttributeTerm term)
	'''
	Story.space.«term.existent.name.toFirstLower».«term.attribute.name.toFirstUpper»
	'''

	def dispatch convertExpression(StoryAttributeTerm term)
	'''
	Story.«term.attribute.name.toFirstUpper»
	'''
	
	def dispatch String convertExpression(IntegerTerm term) {
		return term.value.toString;
	}

	def dispatch String convertExpression(BooleanTerm term) {
		return term.value;
	}
	

	def dispatch convertExpression(Expression e) ''' [«e.toString»] '''

	
	
	/* 
     * OPERATORS
     */
	
	def convert(AttributionOperator op)
	'''
	«IF op == AttributionOperator.ASSIGN»=
	«ELSEIF op == AttributionOperator.INCREMENT»+=
	«ELSEIF op == AttributionOperator.DECREMENT»-=
	«ELSE»«op.literal»
	«ENDIF»
	'''
	
	def convert(Order order)
	'''
	«IF order == Order.AFTER»>
	«ELSEIF order == Order.BEFORE»<
	«ELSE»«order.literal»
	«ENDIF»
	'''
	
	
	/* 
     * C# Keywords
     */
     
	static class CSkeys {
		static String parOpen = '('
		static String parClose = ')'
		static String and = ' && '
		static String or = ' || '
		static String not = '!'
	}
	

}
